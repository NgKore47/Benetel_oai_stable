--- ../../E_release/openairinterface5g/cmake_targets/tools/oran_fhi_integration_patches/E/oaioran_E.patch	2024-12-18 20:38:53.197073572 +0530
+++ ../openairinterface5g/cmake_targets/tools/oran_fhi_integration_patches/F/oaioran_F.patch	2024-12-14 07:24:47.416196991 +0530
@@ -1,45 +1,55 @@
 diff --git a/fhi_lib/app/src/common.h b/fhi_lib/app/src/common.h
-index 7508117..ce17ebd 100644
+index ac5f471..bbd39fe 100644
 --- a/fhi_lib/app/src/common.h
 +++ b/fhi_lib/app/src/common.h
 @@ -28,7 +28,7 @@
  #include <rte_common.h>
  #include <rte_mbuf.h>
  
--#define VERSIONX                "oran_e_maintenance_release_v1.0"
-+#define VERSIONX                "oran_e_maintenance_release_v1.4"
+-#define VERSIONX                "oran_f_release_v1.0"
++#define VERSIONX                "oran_f_release_v1.1"
  
  #define APP_O_DU  0
  #define APP_O_RU  1
 diff --git a/fhi_lib/lib/Makefile b/fhi_lib/lib/Makefile
-index de141bf..c12b912 100644
+index eccc4ae..8ddb22e 100644
 --- a/fhi_lib/lib/Makefile
 +++ b/fhi_lib/lib/Makefile
-@@ -23,11 +23,11 @@ MYCUSTOMSPACE1='------------------------------------------------------------'
+@@ -23,12 +23,18 @@ MYCUSTOMSPACE1='------------------------------------------------------------'
  ##############################################################
  #  Tools configuration
  ##############################################################
+-ifeq ($(WIRELESS_SDK_TOOLCHAIN),icc)
 -CC  := icc
 -CPP := icpc
-+CC  := gcc
-+CPP := g++
- AS := as
- AR := ar
+-AS := as
+-AR := ar
 -LD := icc
-+LD := gcc
- OBJDUMP := objdump
- 
- ifeq ($(SHELL),cmd.exe)
-@@ -57,7 +57,7 @@ endif
++ifeq ($(WIRELESS_SDK_TOOLCHAIN),gcc)
++    CC  := gcc
++    CPP := g++
++    AS := as
++    AR := ar
++    LD := gcc
++else ifeq ($(WIRELESS_SDK_TOOLCHAIN),icc)
++    CC  := icc
++    CPP := icpc
++    AS := as
++    AR := ar
++    LD := icc
+ else ifeq ($(WIRELESS_SDK_TOOLCHAIN),icx)
+     CC  := icx
+     CPP := icpx
+@@ -72,7 +78,7 @@ ifeq ($(RTE_SDK),)
+ endif
  
  RTE_TARGET ?= x86_64-native-linux-icc
- 
 -RTE_INC := $(shell PKG_CONFIG_PATH=/usr/lib64/pkgconfig:$(RTE_SDK)/build/meson-uninstalled pkgconf --cflags-only-I libdpdk)
 +RTE_INC := $(shell PKG_CONFIG_PATH=$(PKG_CONFIG_PATH):/usr/lib64/pkgconfig:$(RTE_SDK)/build/meson-uninstalled pkgconf --cflags-only-I libdpdk)
+ 
  API_DIR := $(PROJECT_DIR)/api
  SRC_DIR := $(PROJECT_DIR)/src
- ETH_DIR := $(PROJECT_DIR)/ethernet
-@@ -95,8 +95,7 @@ CPP_SRC = $(SRC_DIR)/xran_compression.cpp \
+@@ -110,8 +116,7 @@ CPP_SRC = $(SRC_DIR)/xran_compression.cpp \
  	$(SRC_DIR)/xran_bfp_cplane32.cpp \
  	$(SRC_DIR)/xran_bfp_cplane64.cpp \
  	$(SRC_DIR)/xran_bfp_uplane_9b16rb.cpp \
@@ -49,40 +59,43 @@
  
  CPP_SRC_SNC = $(SRC_DIR)/xran_compression_snc.cpp \
  	$(SRC_DIR)/xran_bfp_cplane8_snc.cpp \
-@@ -112,12 +111,12 @@ CC_FLAGS += -std=gnu11 -Wall -Wno-deprecated-declarations  \
+@@ -127,7 +132,7 @@ CC_FLAGS += -std=gnu11 -Wall -Wno-deprecated-declarations  \
          -fPIC \
  	-Wall \
  	-Wimplicit-function-declaration \
--	-g -O3 -wd1786 -mcmodel=large
+-	-g -O3 -mcmodel=large
 +	-g -O -mavx512bw -march=skylake-avx512 -mtune=skylake-avx512#--wd1786 -mcmodel=large
  
--CPP_FLAGS := -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D_GNU_SOURCE -D_REENTRANT -pipe -no-prec-div \
--                -no-prec-div -fp-model fast=2 -fPIC \
--                -no-prec-sqrt  -falign-functions=16 -fast-transcendentals \
--        -Werror -Wno-unused-variable -std=c++14 -mcmodel=large
-+CPP_FLAGS := -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D_GNU_SOURCE -D_REENTRANT -pipe \
+ ifeq ($(WIRELESS_SDK_TOOLCHAIN),icc)
+ CC_FLAGS += -wd1786 -restrict
+@@ -138,8 +143,9 @@ CC_FLAGS += -march=icelake-server -mintrinsic-promote -Wno-unused-function -Wno-
+ endif
+ 
+ CPP_FLAGS := -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D_GNU_SOURCE -D_REENTRANT -pipe \
+-                  -falign-functions=16 \
+-        -Werror -Wno-unused-variable -std=c++14 -mcmodel=large -fPIC
 +                -fPIC \
 +                -falign-functions=16  \
 +        -Werror -Wno-unused-variable -std=c++14 -mcmodel=large -mavx512bw -march=skylake-avx512 -mtune=skylake-avx512
  
- INC :=  -I$(API_DIR) -I$(ETH_DIR) -I$(SRC_DIR) -I$(RTE_INC)
- DEF :=
-@@ -150,8 +149,8 @@ CPP_SNC_OBJTARGETS := $(addprefix $(PROJECT_OBJ_DIR)/,$(CPP_OBJS_SNC))
+ ifeq ($(WIRELESS_SDK_TOOLCHAIN),icc)
+ CPP_FLAGS +=  -fp-model fast=2 -no-prec-div -no-prec-sqrt -fast-transcendentals -restrict
+@@ -186,8 +192,8 @@ CPP_SNC_OBJTARGETS := $(addprefix $(PROJECT_OBJ_DIR)/,$(CPP_OBJS_SNC))
  
  AS_OBJTARGETS := $(addprefix $(PROJECT_OBJ_DIR)/,$(AS_OBJS))
  #-qopt-report=5 -qopt-matmul -qopt-report-phase=all
--CPP_COMP       := -O3 -DNDEBUG  -xcore-avx512 -fPIE -restrict -fasm-blocks
--CPP_COMP_SNC   := -O3 -DNDEBUG -march=icelake-server -fPIE -restrict -fasm-blocks
+-CPP_COMP       := -O3 -DNDEBUG  -xcore-avx512 -fPIE -fasm-blocks
+-CPP_COMP_SNC   := -O3 -DNDEBUG -march=icelake-server -fPIE -fasm-blocks
 +CPP_COMP       := -O3 -DNDEBUG  -fPIE
 +CPP_COMP_SNC   := -O3 -DNDEBUG -march=icelake-server -fPIE
  CC_FLAGS_FULL  := $(CC_FLAGS)  $(INC) $(DEF)
  CPP_FLAGS_FULL := $(CPP_FLAGS) $(CPP_COMP) $(INC) $(DEF)
  CPP_FLAGS_FULL_SNC := $(CPP_FLAGS) $(CPP_COMP_SNC) $(INC) $(DEF)
 diff --git a/fhi_lib/lib/api/xran_fh_o_du.h b/fhi_lib/lib/api/xran_fh_o_du.h
-index 7419ae1..a85f973 100644
+index bacf597..90a42a2 100644
 --- a/fhi_lib/lib/api/xran_fh_o_du.h
 +++ b/fhi_lib/lib/api/xran_fh_o_du.h
-@@ -1104,6 +1104,30 @@ int32_t xran_reg_physide_cb(void *pHandle, xran_fh_tti_callback_fn Cb, void *cbP
+@@ -1193,6 +1193,31 @@ int32_t xran_reg_physide_cb_by_dev_id(void *pHandle, xran_fh_tti_callback_fn Cb,
   */
  int32_t xran_get_slot_idx (uint32_t PortId, uint32_t *nFrameIdx, uint32_t *nSubframeIdx,  uint32_t *nSlotIdx, uint64_t *nSecond);
  
@@ -109,12 +122,13 @@
 + * @return
 + *   current TTI number [0-7999]
 + */
-+int32_t xran_get_slot_idx_from_tti (uint32_t tti, uint32_t *nFrameIdx, uint32_t *nSubframeIdx,  uint32_t *              nSlotIdx, uint64_t *nSecond);
++int32_t xran_get_slot_idx_from_tti(uint32_t tti, uint32_t *nFrameIdx, uint32_t *nSubframeIdx, uint32_t *nSlotIdx, uint64_t *nSecond);
++
  /**
   * @ingroup xran
   *
 diff --git a/fhi_lib/lib/api/xran_up_api.h b/fhi_lib/lib/api/xran_up_api.h
-index 7d3afc5..e2f1f21 100644
+index 46e0e1d..409ef4b 100644
 --- a/fhi_lib/lib/api/xran_up_api.h
 +++ b/fhi_lib/lib/api/xran_up_api.h
 @@ -80,6 +80,7 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
@@ -133,13 +147,13 @@
 +    uint8_t *iqWidth,
 +    uint8_t *is_prach);
  
- inline int xran_prepare_iq_symbol_portion(
+ int xran_prepare_iq_symbol_portion(
                          struct rte_mbuf *mbuf,
 diff --git a/fhi_lib/lib/ethernet/ethdi.c b/fhi_lib/lib/ethernet/ethdi.c
-index b6ba257..1618f65 100644
+index f5b2fd6..e949fe7 100644
 --- a/fhi_lib/lib/ethernet/ethdi.c
 +++ b/fhi_lib/lib/ethernet/ethdi.c
-@@ -326,8 +326,8 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
+@@ -325,8 +325,8 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
      char bbdev_wdev[32]   = "";
      char bbdev_vdev[32]   = "";
      char iova_mode[32]    = "--iova-mode=pa";
@@ -149,16 +163,17 @@
 +    char socket_limit[32] = "--socket-limit=0";
      char ring_name[32]    = "";
      int32_t xran_port = -1;
-     portid_t port_id;
-@@ -335,6 +335,7 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
-     uint16_t count;
+     queueid_t qi = 0;
+@@ -336,7 +336,7 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
+     cpu = sched_getcpu();
+     node = numa_node_of_cpu(cpu);
  
-     char *argv[] = { name, core_mask, "-n2", iova_mode, socket_mem, socket_limit, "--proc-type=auto",
-+        "--no-telemetry",
+-    char *argv[] = { name, core_mask, "-n2", iova_mode, socket_mem, socket_limit, "--proc-type=auto",
++    char *argv[] = { name, core_mask, "-n2", iova_mode, socket_mem, socket_limit, "--proc-type=auto", "--no-telemetry",
          "--file-prefix", name, "-a0000:00:00.0", bbdev_wdev, bbdev_vdev};
  
- 
-@@ -479,11 +480,13 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
+     if (io_cfg == NULL)
+@@ -481,11 +481,13 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
                      ctx->tx_ring[i] = rte_ring_create(ring_name, NUM_MBUFS_RING_TRX,
                      rte_lcore_to_socket_id(*lcore_id), RING_F_SC_DEQ);
                      PANIC_ON(ctx->tx_ring[i] == NULL, "failed to allocate rx ring");
@@ -172,7 +187,7 @@
                      }
                  }
              } else {
-@@ -553,7 +556,7 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
+@@ -555,7 +557,7 @@ xran_ethdi_init_dpdk_io(char *name, const struct xran_io_cfg *io_cfg,
          ctx->up_dl_pkt_gen_ring[i] = rte_ring_create(ring_name, NUM_MBUFS_RING,
          rte_lcore_to_socket_id(*lcore_id), /*RING_F_SC_DEQ*/0);
          PANIC_ON(ctx->up_dl_pkt_gen_ring[i] == NULL, "failed to allocate dl gen ring");
@@ -194,7 +209,7 @@
  static int16_t saturateAbs(int16_t inVal)
  {
 diff --git a/fhi_lib/lib/src/xran_bfp_uplane.cpp b/fhi_lib/lib/src/xran_bfp_uplane.cpp
-index a345df4..2a94e01 100644
+index 59b6850..322d238 100644
 --- a/fhi_lib/lib/src/xran_bfp_uplane.cpp
 +++ b/fhi_lib/lib/src/xran_bfp_uplane.cpp
 @@ -90,7 +90,7 @@ namespace BFP_UPlane
@@ -224,17 +239,23 @@
      /// Store exponent first
      dataOut->dataCompressed[thisRBExpAddr] = thisExp;
      /// Now have 1 RB worth of bytes separated into 3 chunks (1 per lane)
+@@ -432,4 +432,4 @@ BlockFloatCompander::BFPExpandUserPlaneAvx512(const CompressedData& dataIn, Expa
+     BFP_UPlane::expandByAllocN<BlockFloatCompander::networkByteUnpack12b>(dataIn, dataOut, k_totNumBytesPerRB12, k_maxExpShift12);
+     break;
+   }
+-}
+\ No newline at end of file
++}
 diff --git a/fhi_lib/lib/src/xran_common.c b/fhi_lib/lib/src/xran_common.c
-index baa673f..00bfdf2 100644
+index dc40ad9..4ac1fbf 100644
 --- a/fhi_lib/lib/src/xran_common.c
 +++ b/fhi_lib/lib/src/xran_common.c
-@@ -650,12 +650,15 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
+@@ -714,11 +714,14 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
      uint8_t compMeth = 0;
      uint8_t iqWidth = 0;
  
 +    uint8_t is_prach = 0;
 +
-     void *pHandle = NULL;
      int ret = MBUF_FREE;
      uint32_t mb_free = 0;
      int32_t valid_res = 0;
@@ -242,69 +263,54 @@
      enum xran_comp_hdr_type staticComp = p_dev_ctx->fh_cfg.ru_conf.xranCompHdrType;
 +    uint8_t filter_id;
  
-     if (staticComp == XRAN_COMP_HDR_TYPE_STATIC)
+     if(first_call == 0)
+         return ret;
+@@ -733,9 +736,9 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
+         return MBUF_FREE;
+ 
+     num_bytes = xran_extract_iq_samples(pkt, &iq_samp_buf,
+-                                &CC_ID, &Ant_ID, &frame_id, &subframe_id, &slot_id, &symb_id, &seq,
++                                &CC_ID, &Ant_ID, &frame_id, &subframe_id, &slot_id, &symb_id, &filter_id, &seq,
+                                 &num_prbu, &start_prbu, &sym_inc, &rb, &sect_id,
+-                                expect_comp, staticComp, &compMeth, &iqWidth);
++                                expect_comp, staticComp, &compMeth, &iqWidth, &is_prach);
+     if (num_bytes <= 0)
      {
-@@ -674,6 +677,7 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
-                                         &subframe_id,
-                                         &slot_id,
-                                         &symb_id,
-+                                        &filter_id,
-                                         &seq,
-                                         &num_prbu,
-                                         &start_prbu,
-@@ -683,28 +687,15 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
-                                         expect_comp,
-                                         staticComp,
-                                         &compMeth,
--                                        &iqWidth);
-+                                        &iqWidth,
-+                                        &is_prach);
-     if (num_bytes <= 0){
          print_err("num_bytes is wrong [%d]\n", num_bytes);
-         return MBUF_FREE;
-     }
--
--    valid_res = xran_pkt_validate(p_dev_ctx,
--                                pkt,
--                                iq_samp_buf,
--                                num_bytes,
--                                CC_ID,
--                                Ant_ID,
--                                frame_id,
--                                subframe_id,
--                                slot_id,
--                                symb_id,
--                                &seq,
--                                num_prbu,
--                                start_prbu,
--                                sym_inc,
--                                rb,
--                                sect_id);
-+    pCnt->rx_counter++;
-+    pCnt->Rx_on_time++;
-+    pCnt->Total_msgs_rcvd++;
+@@ -781,10 +784,9 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
+ 
+     else
+     {
+-        valid_res = xran_pkt_validate(p_dev_ctx,
+-                                pkt, iq_samp_buf, num_bytes,
+-                                CC_ID, Ant_ID, frame_id, subframe_id, slot_id, symb_id,
+-                                &seq, num_prbu, start_prbu, sym_inc, rb, sect_id);
++        pCnt->rx_counter++;
++        pCnt->Rx_on_time++;
++        pCnt->Total_msgs_rcvd++;
  #ifndef FCN_ADAPT
-     if(valid_res != 0) {
-         print_dbg("valid_res is wrong [%d] ant %u (%u : %u : %u : %u) seq %u num_bytes %d\n", valid_res, Ant_ID, frame_id, subframe_id, slot_id, symb_id, seq.seq_id, num_bytes);
-@@ -756,7 +747,7 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
-             print_dbg("Transport layer fragmentation (eCPRI) is not supported\n");
+         if(valid_res != 0)
+         {
+@@ -807,8 +809,7 @@ process_mbuf(struct rte_mbuf *pkt, void* handle, struct xran_eaxc_info *p_cid)
+             PrachCfg = &(p_dev_ctx->PrachCPConfig);
          }
  
--    } else if (Ant_ID >= p_dev_ctx->PrachCPConfig.eAxC_offset && p_dev_ctx->fh_cfg.prachEnable) {
-+    } else if (/*Ant_ID >= p_dev_ctx->PrachCPConfig.eAxC_offset && */p_dev_ctx->fh_cfg.prachEnable && is_prach) {
+-        if (Ant_ID >= PrachCfg->eAxC_offset && p_dev_ctx->fh_cfg.prachEnable)
+-        {
++        if (/*Ant_ID >= PrachCfg->eAxC_offset &&*/p_dev_ctx->fh_cfg.prachEnable && is_prach) {
          /* PRACH packet has ruportid = num_eAxc + ant_id */
-         Ant_ID -= p_dev_ctx->PrachCPConfig.eAxC_offset;
+             Ant_ID -= PrachCfg->eAxC_offset;
          symbol_total_bytes[p_dev_ctx->xran_port_id][CC_ID][Ant_ID] += num_bytes;
-@@ -1189,7 +1180,7 @@ int generate_cpmsg_prach(void *pHandle, struct xran_cp_gen_params *params, struc
-         timeOffset += startSymId * (2048 + 144);
-     }
+@@ -1412,7 +1413,7 @@ int generate_cpmsg_prach(void *pHandle, struct xran_cp_gen_params *params, struc
+     if(XRAN_FILTERINDEX_PRACH_ABC == pPrachCPConfig->filterIdx)
+     {
      timeOffset = timeOffset >> nNumerology; //original number is Tc, convert to Ts based on mu
 -    if ((slot_id == 0) || (slot_id == (SLOTNUM_PER_SUBFRAME(pxran_lib_ctx->interval_us_local) >> 1)))
 +    if (startSymId > 0 && ((slot_id == 0) || (slot_id == (SLOTNUM_PER_SUBFRAME(pxran_lib_ctx->interval_us_local) >> 1))))
          timeOffset += 16;
- 
-     params->dir                  = XRAN_DIR_UL;
-@@ -1295,8 +1286,7 @@ int32_t ring_processing_func(void* args)
+     }
+     else
+@@ -1547,8 +1548,7 @@ int32_t ring_processing_func(void* args)
  
      for (i = 0; i < ctx->io_cfg.num_vfs && i < XRAN_VF_MAX; i++){
          for(qi = 0; qi < ctx->rxq_per_port[i]; qi++) {
@@ -314,19 +320,6 @@
          }
      }
  
-diff --git a/fhi_lib/lib/src/xran_common.h b/fhi_lib/lib/src/xran_common.h
-index 3ed75cd..d61fe7f 100644
---- a/fhi_lib/lib/src/xran_common.h
-+++ b/fhi_lib/lib/src/xran_common.h
-@@ -221,7 +221,7 @@ int generate_cpmsg_prach(void *pHandle, struct xran_cp_gen_params *params, struc
- struct xran_eaxcid_config *xran_get_conf_eAxC(void *pHandle);
- int xran_register_cb_mbuf2ring(xran_ethdi_mbuf_send_fn mbuf_send_cp, xran_ethdi_mbuf_send_fn mbuf_send_up);
- 
--uint16_t xran_alloc_sectionid(void *pHandle, uint8_t dir, uint8_t cc_id, uint8_t ant_id, uint8_t slot_id);
-+//uint16_t xran_alloc_sectionid(void *pHandle, uint8_t dir, uint8_t cc_id, uint8_t ant_id, uint8_t slot_id);
- uint8_t xran_get_seqid(void *pHandle, uint8_t dir, uint8_t cc_id, uint8_t ant_id, uint8_t slot_id);
- int32_t ring_processing_func(void* arg);
- int xran_init_prach(struct xran_fh_config* pConf, struct xran_device_ctx * p_xran_dev_ctx);
 diff --git a/fhi_lib/lib/src/xran_compression.cpp b/fhi_lib/lib/src/xran_compression.cpp
 index 112caae..7c74342 100644
 --- a/fhi_lib/lib/src/xran_compression.cpp
@@ -368,10 +361,10 @@
      } else {
          return xranlib_decompress_avx512_bfw(request,response);
 diff --git a/fhi_lib/lib/src/xran_main.c b/fhi_lib/lib/src/xran_main.c
-index 89dcc1f..640f6b6 100644
+index 7c472d7..7bab6a8 100644
 --- a/fhi_lib/lib/src/xran_main.c
 +++ b/fhi_lib/lib/src/xran_main.c
-@@ -272,7 +272,7 @@ xran_init_prach(struct xran_fh_config* pConf, struct xran_device_ctx * p_xran_de
+@@ -306,7 +306,7 @@ xran_init_prach(struct xran_fh_config* pConf, struct xran_device_ctx * p_xran_de
          printf("PRACH start symbol %u lastsymbol %u\n", p_xran_dev_ctx->prach_start_symbol[0], p_xran_dev_ctx->prach_last_symbol[0]);
      }
  
@@ -380,16 +373,7 @@
      print_dbg("PRACH eAxC_offset %d\n",  pPrachCPConfig->eAxC_offset);
  
      /* Save some configs for app */
-@@ -844,7 +844,7 @@ tx_cp_ul_cb(struct rte_timer *tim, void *arg)
-                         struct xran_cp_gen_params params;
-                         struct xran_section_gen_info sect_geninfo[8];
-                         struct rte_mbuf *mbuf = xran_ethdi_mbuf_alloc();
--                        prach_port_id = ant_id + num_eAxc;
-+                        prach_port_id = ant_id + pPrachCPConfig->eAxC_offset;
-                         /* start new section information list */
-                         xran_cp_reset_section_info(pHandle, XRAN_DIR_UL, cc_id, prach_port_id, ctx_id);
- 
-@@ -1059,6 +1059,7 @@ int32_t handle_ecpri_ethertype(struct rte_mbuf* pkt_q[], uint16_t xport_id, stru
+@@ -1570,6 +1570,7 @@ int32_t handle_ecpri_ethertype(struct rte_mbuf* pkt_q[], uint16_t xport_id, stru
          {
          case ECPRI_IQ_DATA:
                  pkt_data[num_data++] = pkt;
@@ -397,7 +381,7 @@
              break;
          // For RU emulation
          case ECPRI_RT_CONTROL_DATA:
-@@ -1076,7 +1077,7 @@ int32_t handle_ecpri_ethertype(struct rte_mbuf* pkt_q[], uint16_t xport_id, stru
+@@ -1587,7 +1588,7 @@ int32_t handle_ecpri_ethertype(struct rte_mbuf* pkt_q[], uint16_t xport_id, stru
                  break;
              default:
                  if (p_dev_ctx->fh_init.io_cfg.id == O_DU) {
@@ -406,7 +390,7 @@
          }
                  break;
      }
-@@ -1771,8 +1772,7 @@ ring_processing_func_per_port(void* args)
+@@ -2347,8 +2348,7 @@ ring_processing_func_per_port(void* args)
      for (i = 0; i < ctx->io_cfg.num_vfs && i < XRAN_VF_MAX; i = i+1) {
          if (ctx->vf2xran_port[i] == port_id) {
              for(qi = 0; qi < ctx->rxq_per_port[port_id]; qi++){
@@ -416,21 +400,22 @@
              }
          }
      }
-@@ -1837,8 +1837,6 @@ xran_spawn_workers(void)
+@@ -2414,9 +2414,6 @@ xran_spawn_workers(void)
          nWorkerCore = nWorkerCore << 1;
      }
  
 -    extern int _may_i_use_cpu_feature(unsigned __int64);
 -    icx_cpu = _may_i_use_cpu_feature(_FEATURE_AVX512IFMA52);
- 
+-
      printf("O-XU      %d\n", eth_ctx->io_cfg.id);
      printf("HW        %d\n", icx_cpu);
-@@ -3074,6 +3072,24 @@ xran_get_slot_idx (uint32_t PortId, uint32_t *nFrameIdx, uint32_t *nSubframeIdx,
+     printf("Num cores %d\n", total_num_cores);
+@@ -4034,6 +4031,24 @@ xran_get_slot_idx (uint32_t PortId, uint32_t *nFrameIdx, uint32_t *nSubframeIdx,
      return tti;
  }
  
 +int32_t
-+xran_get_slot_idx_from_tti (uint32_t tti, uint32_t *nFrameIdx, uint32_t *nSubframeIdx,  uint32_t *nSlotIdx, uint64_t *nSecond)
++xran_get_slot_idx_from_tti(uint32_t tti, uint32_t *nFrameIdx, uint32_t *nSubframeIdx, uint32_t *nSlotIdx, uint64_t *nSecond)
 +{
 +    struct xran_device_ctx * p_xran_dev_ctx = xran_dev_get_ctx_by_id(0);
 +    if (!p_xran_dev_ctx)
@@ -451,10 +436,10 @@
  xran_set_debug_stop(int32_t value, int32_t count)
  {
 diff --git a/fhi_lib/lib/src/xran_mod_compression.cpp b/fhi_lib/lib/src/xran_mod_compression.cpp
-index 7d4a5d0..87bdbd5 100644
+index 7d4a5d0..b9b44ac 100644
 --- a/fhi_lib/lib/src/xran_mod_compression.cpp
 +++ b/fhi_lib/lib/src/xran_mod_compression.cpp
-@@ -747,10 +747,11 @@ int xranlib_5gnr_mod_compression(const struct xranlib_5gnr_mod_compression_reque
+@@ -747,9 +747,9 @@ int xranlib_5gnr_mod_compression(const struct xranlib_5gnr_mod_compression_reque
  #ifdef C_Module_Used
      return (xranlib_5gnr_mod_compression_c(request, response));
  #else
@@ -464,30 +449,13 @@
 -    else
 +    } else {
          return (xranlib_5gnr_mod_compression_avx512(request, response));
-+    }
  #endif
  }
- 
-diff --git a/fhi_lib/lib/src/xran_rx_proc.c b/fhi_lib/lib/src/xran_rx_proc.c
-index 36bd72c..f7f5678 100644
---- a/fhi_lib/lib/src/xran_rx_proc.c
-+++ b/fhi_lib/lib/src/xran_rx_proc.c
-@@ -107,6 +107,10 @@ int xran_process_prach_sym(void *arg,
-             if(mb)
-                 rte_pktmbuf_free(mb);
- 
-+            mb = p_xran_dev_ctx->sFHPrachRxBbuIoBufCtrlDecomp[tti % XRAN_N_FE_BUF_LEN][CC_ID][Ant_ID].sBufferList.pBuffers[symb_id_offset].pCtrl;
-+            if(mb)
-+                rte_pktmbuf_free(mb);
-+
-             if(p_xran_dev_ctx->fh_cfg.ru_conf.byteOrder == XRAN_CPU_LE_BYTE_ORDER) {
-                 int idx = 0;
-                 uint16_t *psrc = (uint16_t *)iq_data_start;
 diff --git a/fhi_lib/lib/src/xran_up_api.c b/fhi_lib/lib/src/xran_up_api.c
-index 397853a..8977e3d 100644
+index fe22a1f..f6c4830 100644
 --- a/fhi_lib/lib/src/xran_up_api.c
 +++ b/fhi_lib/lib/src/xran_up_api.c
-@@ -329,6 +329,7 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
+@@ -336,6 +336,7 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
      uint8_t *subframe_id,
      uint8_t *slot_id,
      uint8_t *symb_id,
@@ -495,7 +463,7 @@
      union ecpri_seq_id *seq_id,
      uint16_t *num_prbu,
      uint16_t *start_prbu,
-@@ -338,7 +339,8 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
+@@ -345,7 +346,8 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
      int8_t   expect_comp,
      enum xran_comp_hdr_type staticComp,
      uint8_t *compMeth,
@@ -505,29 +473,21 @@
  {
  #if XRAN_MLOG_VAR
      uint32_t mlogVar[10];
-@@ -374,6 +376,8 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
+@@ -381,6 +383,7 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
          return 0;       /* packet too short */
  
      radio_hdr->sf_slot_sym.value = rte_be_to_cpu_16(radio_hdr->sf_slot_sym.value);
-+    if (radio_hdr->data_feature.filter_id > 0) *is_prach = 1;
-+    else *is_prach = 0;
++    *is_prach = (radio_hdr->data_feature.filter_id > 0);
  
      if (frame_id)
          *frame_id    = radio_hdr->frame_id;
-@@ -387,6 +391,8 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
+@@ -394,6 +397,9 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
      if (symb_id)
          *symb_id = radio_hdr->sf_slot_sym.symb_id;
  
 +    if (filter_id)
-+	*filter_id = radio_hdr->data_feature.filter_id;
++	    *filter_id = radio_hdr->data_feature.filter_id;
++
      /* Process data section hdr */
      struct data_section_hdr *data_hdr =
          (void *)rte_pktmbuf_adj(mbuf, sizeof(*radio_hdr));
-@@ -401,6 +407,7 @@ int32_t xran_extract_iq_samples(struct rte_mbuf *mbuf,
-     *sym_inc    = data_hdr->fields.sym_inc;
-     *rb         = data_hdr->fields.rb;
-     *sect_id    = data_hdr->fields.sect_id;
-+    if (*num_prbu == 0) *num_prbu=273;
- 
-     if(expect_comp) {
-             const struct data_section_compression_hdr *data_compr_hdr;
